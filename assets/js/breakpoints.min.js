/* breakpoints.js v1.0 | @ajlkn | MIT licensed */
/* breakpoints.js v1.0 | @ajlkn | MIT licensed */

/**
 * Private methods
 */

// Initialize the breakpoints
var e = function (list) {
	// Initialize the breakpoints
	t.init(list);
};

// Private methods
var t = {
	list: null,
	media: {},
	events: [],

	// Initialize the breakpoints
	init: function (list) {
		t.list = list;
		window.addEventListener('resize', t.poll);
		window.addEventListener('orientationchange', t.poll);
		window.addEventListener('load', t.poll);
		window.addEventListener('fullscreenchange', t.poll);
	},

	// Test if a breakpoint is active
	active: function (query) {
		var match, value, a, n, comparison, i, r, d, c;

		// Check if query has a min and max
		if (query in t.media) {
			// Find the matching media query
			match = t.media[query];
			if (match) {
				// Test if the media query matches
				return window.matchMedia(match).matches;
			}
		}

		// Parse the query
		if (query.substr(0, 2) === '>=') {
			a = 'gte';
			n = query.substr(2);
		} else if (query.substr(0, 2) === '<=') {
			a = 'lte';
			n = query.substr(2);
		} else if (query.substr(0, 1) === '>') {
			a = 'gt';
			n = query.substr(1);
		} else if (query.substr(0, 1) === '<') {
			a = 'lt';
			n = query.substr(1);
		} else if (query.substr(0, 1) === '!') {
			a = 'not';
			n = query.substr(1);
		} else {
			a = 'eq';
			n = query;
		}

		// Test if query is a valid breakpoint
		if (n && n in t.list) {
			// Parse the breakpoint
			i = t.list[n];
			if (Array.isArray(i)) {
				r = parseInt(i[0], 10);
				d = parseInt(i[1], 10);
				if (isNaN(r)) {
					c = i[1].substr(String(d).length);
				} else {
					c = i[0].substr(String(r).length);
				}

				// Generate the media query
				if (isNaN(r)) {
					switch (a) {
						case 'gte':
							match = 'screen';
							break;
						case 'lte':
							match = 'screen and (max-width: ' + d + c + ')';
							break;
						case 'gt':
							match = 'screen and (min-width: ' + (d + 1) + c + ')';
							break;
						case 'lt':
							match = 'screen and (max-width: -1px)';
							break;
						case 'not':
							match = 'screen and (min-width: ' + (d + 1) + c + ')';
							break;
						default:
							match = 'screen and (max-width: ' + d + c + ')';
					}
				} else if (isNaN(d)) {
					switch (a) {
						case 'gte':
							match = 'screen and (min-width: ' + r + c + ')';
							break;
						case 'lte':
							match = 'screen';
							break;
						case 'gt':
							match = 'screen and (max-width: -1px)';
							break;
						case 'lt':
							match = 'screen and (max-width: ' + (r - 1) + c + ')';
							break;
						case 'not':
							match = 'screen and (max-width: ' + (r - 1) + c + ')';
							break;
						default:
							match = 'screen and (min-width: ' + r + c + ')';
					}
				} else {
					switch (a) {
						case 'gte':
							match = 'screen and (min-width: ' + r + c + ')';
							break;
						case 'lte':
							match = 'screen and (max-width: ' + d + c + ')';
							break;
						case 'gt':
							match = 'screen and (min-width: ' + (d + 1) + c + ')';
							break;
						case 'lt':
							match = 'screen and (max-width: ' + (r - 1) + c + ')';
							break;
						case 'not':
							match = 'screen and (max-width: ' + (r - 1) + c + '), screen and (min-width: ' + (d + 1) + c + ')';
							break;
						default:
							match = 'screen and (min-width: ' + r + c + ') and (max-width: ' + d + c + ')';
					}
				}

				// Store the media query
				t.media[query] = match;
			}
		}

		// Test if the media query matches
		return window.matchMedia(t.media[query]).matches;
	},

	// Event handlers
	on: function (query, handler) {
		// Add the event handler
		t.events.push({ query: query, handler: handler, state: !1 });

		// Check if the media query matches
		t.active(query) && handler();
	},

	// Polling
	poll: function () {
		// Loop through the event handlers
		var i, n;
		for (i = 0; i < t.events.length; i++) {
			n = t.events[i];

			// Check if the media query matches
			if (t.active(n.query)) {
				n.state || (n.state = !0, n.handler());
			} else {
				n.state && (n.state = !1);
			}
		}
	}
};

// Public methods
var breakpoints = function () {
	// Initialize the breakpoints
	e.apply(this, arguments);
};

// Public methods
breakpoints._ = t;
breakpoints.on = function (query, handler) {
	t.on(query, handler);
};
breakpoints.active = function (query) {
	return t.active(query);
};

// Expose breakpoints
!function (root, factory) {
	// AMD
	if (typeof define === 'function' && define.amd) {
		define([], factory);

	// CommonJS
	} else if (typeof exports === 'object') {
		module.exports = factory();

	// Global
	} else {
		root.breakpoints = factory();
	}
}(this, function () {
	return breakpoints;
});
